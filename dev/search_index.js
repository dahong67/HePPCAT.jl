var documenterSearchIndex = {"docs":
[{"location":"updates/","page":"Update Methods","title":"Update Methods","text":"CurrentModule = HePPCAT","category":"page"},{"location":"updates/#Update-Methods","page":"Update Methods","title":"Update Methods","text":"","category":"section"},{"location":"updates/","page":"Update Methods","title":"Update Methods","text":"warning: Under Construction...\nThese docs are still under construction.","category":"page"},{"location":"updates/#Factor-Matrix-Updates","page":"Update Methods","title":"Factor Matrix Updates","text":"","category":"section"},{"location":"updates/#Experimental-U-Î»-Updates","page":"Update Methods","title":"Experimental U-Î» Updates","text":"","category":"section"},{"location":"updates/#Variance-Updates","page":"Update Methods","title":"Variance Updates","text":"","category":"section"},{"location":"init/","page":"Initialization","title":"Initialization","text":"CurrentModule = HePPCAT","category":"page"},{"location":"init/#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"init/","page":"Initialization","title":"Initialization","text":"warning: Under Construction...\nThese docs are still under construction.","category":"page"},{"location":"vknown/","page":"Known / Bounded Variances","title":"Known / Bounded Variances","text":"CurrentModule = HePPCAT","category":"page"},{"location":"vknown/#Known-/-Bounded-Variances","page":"Known / Bounded Variances","title":"Known / Bounded Variances","text":"","category":"section"},{"location":"vknown/","page":"Known / Bounded Variances","title":"Known / Bounded Variances","text":"warning: Under Construction...\nThese docs are still under construction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HePPCAT","category":"page"},{"location":"#HePPCAT:-HEteroscedastic-Probabilistic-PCA-Technique","page":"Home","title":"HePPCAT: HEteroscedastic Probabilistic PCA Technique","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HePPCAT.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ðŸ‘‹ This package provides research code and work is ongoing. If you are interested in using it in your own research, I'd love to hear from you and collaborate! Feel free to write: dahong67@wharton.upenn.edu","category":"page"},{"location":"#What-is-HePPCAT?","page":"Home","title":"What is HePPCAT?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HePPCAT is a probabilistic Principal Component Analysis (PCA) technique for data that has samples with heterogeneous quality, i.e., noise that is heteroscedastic across samples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Illustration: data points with a group of noisier samples (blue points) and a group of cleaner samples (green points).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using HePPCAT\nusing CairoMakie, StableRNGs\n\n## Setup\nd = 2\nn = [400,100]\nv = [4,0.04]\nF = ones(d,1)/sqrt(d)\n\n## Generate data\nrng = StableRNG(0)\nX = [F*randn(rng,nl)' + sqrt(vl)*randn(rng,d,nl) for (nl,vl) in zip(n,v)]\n\n## Compute estimates\nmodels = [\n    \"(Homoscedastic) PPCA\"           => heppcat(X,1,0),    # init is homoscedastic PPCA\n    \"Heteroscedastic PPCA (HePPCAT)\" => heppcat(X,1,1000)\n]\n\n## Plot\ndatacolors = [:dodgerblue1,:green3]\nfig = Figure(; resolution=(800,600))\nfor (idx,(title,M)) in enumerate(models)\n    # Data and axes\n    ax = Axis(fig[1,idx]; title=title)\n\n    # Latent axis\n    text!(ax,[(5.7,5.7)]; text=\"true component\",\n        fontsize=16.0,align=(:right,:top),rotation=pi/4)\n    ablines!(ax,[0.0],[1.0]; linewidth=3,color=:black)\n\n    # Data points\n    for (Xl,color) in zip(X,datacolors)\n        scatter!(ax,Xl[1,:],Xl[2,:]; strokewidth=0.2,markersize=6,color=color)\n    end\n\n    # Estimate\n    text!(ax,[(M.U[1],M.U[2]).*([4.5,5.7][idx]*sqrt(2))]; text=\"estimate\",\n        fontsize=16.0,align=(:right,:bottom),rotation=atan(M.U[2]/M.U[1]),\n        color=:darkorange1)\n    ablines!(ax,[0.0],[M.U[2]/M.U[1]]; linewidth=3,color=:darkorange1)\n\n    # Formatting\n    ax.autolimitaspect = 1\n    ax.xticks = 0:0\n    ax.yticks = 0:0\n    limits!(ax,(-6.25,6.25),(-6.25,6.25))\n    hidedecorations!(ax,grid=false)\n\n    # Noise variance estimates\n    ax = Axis(fig[2,idx])\n    scatter!(ax,reduce(vcat,fill.(M.v,n));\n        color=reduce(vcat,fill.(datacolors,n)),strokecolor=:transparent,markersize=2)\n    ax.xticks = [0,n[1],sum(n)]\n    ax.yticks = v\n    limits!(ax,(0,sum(n)),(-1,5))\n    hidedecorations!(ax,grid=false)\nend\n\n# Legend\nleg = Legend(fig[3,:],\n    [MarkerElement(marker=:circle,color=c,strokecolor=:transparent) for c in datacolors],\n    [\"Noisier samples\",\"Cleaner samples\"]\n)\nleg.labelsize = 15\nleg.tellheight = true\nleg.orientation = :horizontal\nleg.framevisible = false\n\n# Format and save\nLabel(fig[1,1,Left()],\"data and estimated components\",fontsize=14,rotation=pi/2)\nLabel(fig[2,1,Left()],\"est. noise\\nvariances\",fontsize=14,rotation=pi/2)\nrowsize!(fig.layout, 2, Relative(1/6))\n\nsave(\"illustration-2D.png\",fig); nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: 2D illustration)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Homoscedastic PPCA estimates only one noise variance for the whole data, and treats samples as though they were all equally noisy. Recovery of latent components can degrade a lot due to the noisier samples, even though the rest of the samples are relatively clean.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HePPCAT estimates latent components along with separate noise variances for each group. It accounts for heterogeneous quality among the samples and is generally more robust.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It's not just a \"cool cat\"!","category":"page"},{"location":"#How-to-cite","page":"Home","title":"How to cite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please cite the following paper for this technique:","category":"page"},{"location":"","page":"Home","title":"Home","text":"David Hong, Kyle Gilman, Laura Balzano, Jeffrey A. Fessler. \"HePPCAT: Probabilistic PCA for Data with Heteroscedastic Noise\", IEEE Transactions on Signal Processing 69:4819-4834, Aug. 2021. https://doi.org/10.1109/TSP.2021.3104979 https://arxiv.org/abs/2101.03468.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In BibTeX form:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{hgbf2021heppcat,\n  title   = \"{HePPCAT}: Probabilistic {PCA} for Data with Heteroscedastic Noise\",\n  author  = \"David Hong and Kyle Gilman and Laura Balzano and Jeffrey A. Fessler\",\n  journal = \"{IEEE} Transactions on Signal Processing\",\n  year    = \"2021\",\n  volume  = \"69\",\n  pages   = \"4819--4834\",\n  DOI     = \"10.1109/tsp.2021.3104979\",\n}","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"CurrentModule = HePPCAT","category":"page"},{"location":"tutorial/#Quick-Start:-How-to-use-HePPCAT","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"","category":"section"},{"location":"tutorial/#Step-0:-Installation","page":"Quick Start: How to use HePPCAT","title":"Step 0: Installation","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"This package is registered and can be installed via the package manager.","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"pkg> add HePPCAT  # type `]` to access this `pkg>` prompt","category":"page"},{"location":"tutorial/#Step-1:-Form-list-of-data-matrices","page":"Quick Start: How to use HePPCAT","title":"Step 1: Form list of data matrices","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"HePPCAT expects the samples to be arranged as columns in matrices, where each matrix corresponds to one noise variance group:","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"mathbfY_1 =\nunderbrace\nbeginbmatrix\n        \n    mathbfy_11  cdots  mathbfy_1n_1 \n       \nendbmatrix\n_d times n_1 text matrix\nquad cdots quad\nmathbfY_L =\nunderbrace\nbeginbmatrix\n        \n    mathbfy_L1  cdots  mathbfy_Ln_L \n       \nendbmatrix\n_d times n_L textmatrix","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"i.e., the samples mathbfy_11dotsmathbfy_1n_1 will have one associated noise variance estimate, the samples mathbfy_21dotsmathbfy_2n_2 will have one associated noise variance estimate, and so on.","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"The following code generates a synthetic set of data (for illustration):","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"d = 100        # number of features (ambient dimension)\nk = 1          # number of factors (latent dimension)\n\nn = [800,200]  # number of samples in each group/block\nv = [10,0.01]  # noise variance for each group/block\nL = length(n)  # number of groups/blocks\n\nF = randn(d,k)/sqrt(d) # synthetic factor matrix\nY = [F*randn(k,n[l]) + sqrt(v[l])*randn(d,n[l]) for l in 1:L]","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"Namely, Y is a list (a Vector) of matrices containing d = 100 dimensional samples:","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"Y[1] has n[1] = 800 samples with a noise variance of v[1] = 10\nY[2] has n[2] = 200 samples with a noise variance of v[2] = 0.01.","category":"page"},{"location":"tutorial/#Step-2:-Run-the-main-function-heppcat","page":"Quick Start: How to use HePPCAT","title":"Step 2: Run the main function heppcat","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"With the package installed and the data Y prepared, simply load the package and run heppcat:","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"using HePPCAT\nmodel = heppcat(Y,k,100)  # run 100 iterations","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"The output is a HePPCATModel that contains the factor matrix and noise variance estimates. Extracting them is as simple as running:","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"model.F\nmodel.v","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"That's it!","category":"page"},{"location":"tutorial/","page":"Quick Start: How to use HePPCAT","title":"Quick Start: How to use HePPCAT","text":"For more examples, see the paper code repo!","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = HePPCAT","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [HePPCAT]","category":"page"},{"location":"docstrings/#HePPCAT.HePPCAT","page":"Docstrings","title":"HePPCAT.HePPCAT","text":"Heteroscedastic PPCA Technique (HePPCAT) module. Provides probabilistic PCA for data with samples of heterogeneous quality (heteroscedastic noise).\n\n\n\n\n\n","category":"module"},{"location":"docstrings/#HePPCAT.ArmijoSearch","page":"Docstrings","title":"HePPCAT.ArmijoSearch","text":"ArmijoSearch{S<:Integer,T<:AbstractFloat}\n\nArmijo line search with parameters:\n\nmaxsearches :: S  maximum number of line searches\nstepsize    :: T  initial stepsize\ncontraction :: T  contraction factor\ntol         :: T  tolerance for sufficient decrease\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.CubicSolvableMinorizer","page":"Docstrings","title":"HePPCAT.CubicSolvableMinorizer","text":"CubicSolvableMinorizer\n\nMinorize maximize update with cubic solvable minorizer. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.DifferenceOfConcave","page":"Docstrings","title":"HePPCAT.DifferenceOfConcave","text":"DifferenceOfConcave\n\nDifference of concave update method. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.ExpectationMaximization","page":"Docstrings","title":"HePPCAT.ExpectationMaximization","text":"ExpectationMaximization\n\nExpectation maximization update method. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.HePPCATModel","page":"Docstrings","title":"HePPCAT.HePPCATModel","text":"HePPCATModel{S<:Number,T<:Real}\n\nModel parameters for probabilistic PCA with noise that is heteroscedastic across samples. This is the return type of heppcat(_), the corresponding estimation function.\n\nProperties\n\nF  :: Matrix    factor matrix (computed via F = U*sqrt(Diagonal(Î»))*Vt)\nU  :: Matrix{S} eigenvectors of factor covariance F*F'\nÎ»  :: Vector{T} eigenvalues of factor covariance F*F' (spike eigenvalues)\nVt :: Matrix{S} (transposed) eigenvectors of F'*F (i.e., right singular vectors of F)\nv  :: Vector{T} noise variances\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.HePPCATModel-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractMatrix{T} where T, AbstractVector{T} where T}","page":"Docstrings","title":"HePPCAT.HePPCATModel","text":"HePPCATModel(U::AbstractMatrix,Î»::AbstractVector,Vt::AbstractMatrix,v::AbstractVector)\n\nConstruct HePPCATModel object from factor eigenstructure and noise variances.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.HePPCATModel-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}","page":"Docstrings","title":"HePPCAT.HePPCATModel","text":"HePPCATModel(F::AbstractMatrix,v::AbstractVector)\n\nConstruct HePPCATModel object from factor matrix and noise variances.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.InverseLipschitz","page":"Docstrings","title":"HePPCAT.InverseLipschitz","text":"InverseLipschitz{T}\n\nInverse Lipschitz step size using bound function specified by field bound::T. Default choice is bound=LipBoundU2.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.MinorizeMaximize","page":"Docstrings","title":"HePPCAT.MinorizeMaximize","text":"MinorizeMaximize\n\nMinorize maximize update method. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.OptimalQuadraticMinorizer","page":"Docstrings","title":"HePPCAT.OptimalQuadraticMinorizer","text":"OptimalQuadraticMinorizer\n\nMinorize maximize update using quadratic minorizer with optimized curvature. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.ProjectedGradientAscent","page":"Docstrings","title":"HePPCAT.ProjectedGradientAscent","text":"ProjectedGradientAscent{T}\n\nProjected gradient ascent update method. One field: stepsize::T.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.ProjectedVariance","page":"Docstrings","title":"HePPCAT.ProjectedVariance","text":"ProjectedVariance{S,T}\n\nUpdate variance using method then project the variance so that the variance iterate does not go below varfloor.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.QuadraticMinorizer","page":"Docstrings","title":"HePPCAT.QuadraticMinorizer","text":"QuadraticMinorizer\n\nMinorize maximize update using quadratic minorizer. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.QuadraticSolvableMinorizer","page":"Docstrings","title":"HePPCAT.QuadraticSolvableMinorizer","text":"QuadraticSolvableMinorizer\n\nMinorize maximize update with quadratic solvable minorizer. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.RootFinding","page":"Docstrings","title":"HePPCAT.RootFinding","text":"RootFinding\n\nRoot-finding (global maximization) update method. No fields.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.StiefelGradientAscent","page":"Docstrings","title":"HePPCAT.StiefelGradientAscent","text":"StiefelGradientAscent{T}\n\nStiefel gradient ascent update method. One field: stepsize::T.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#HePPCAT.F-NTuple{4, Any}","page":"Docstrings","title":"HePPCAT.F","text":"F(U,Î»,v,Y)\n\nObjective for the optimization problem w.r.t U.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.LipBoundU1-Tuple{HePPCATModel, Any}","page":"Docstrings","title":"HePPCAT.LipBoundU1","text":"LipBoundU1(M::HePPCATModel,Y)\n\nLipschitz bound of objective w.r.t. U at M with data Y.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.LipBoundU2-Tuple{HePPCATModel, Any}","page":"Docstrings","title":"HePPCAT.LipBoundU2","text":"LipBoundU2(M::HePPCATModel,Y)\n\nLipschitz bound of objective w.r.t. U at M with data Y.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.geodesic-Tuple{Any, Any, Any}","page":"Docstrings","title":"HePPCAT.geodesic","text":"geodesic(U,X,t)\n\nGeodesic step of size t from U in direction of X along the Stiefel manifold.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.gradF-NTuple{4, Any}","page":"Docstrings","title":"HePPCAT.gradF","text":"gradF(U,Î»,v,Y)\n\nEuclidean gradient of objective for the optimization problem w.r.t U.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.heppcat-Tuple{Any, Any, Integer}","page":"Docstrings","title":"HePPCAT.heppcat","text":"heppcat(Y,k,iters;init=homppca(Y,k),vknown=false,varfloor=zero(eltype(init.v)))\n\nEstimate probabilistic PCA model for noise that is heteroscedastic across samples.\n\nRequired Inputs\n\nY : list of matrices (each column is a sample)\nk : number of factors\niters  : number of iterations to run\n\nOptional Keyword Arguments\n\ninit   : initial model (will be modified in-place)\nvknown : variances are known (do not update) default false\nvarfloor : lower bound for variance iterates (useful if the iterates are degenerating to zero) default = 0\n\nOutput is a HePPCATModel object.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.homppca-Tuple{Any, Any}","page":"Docstrings","title":"HePPCAT.homppca","text":"homppca(Y,k)\n\nEstimate probabilistic PCA model for noise that is homoscedastic across samples.\n\nInputs are:\n\nY : list of matrices (each column is a sample)\nk : number of factors\n\nOutput is a HePPCATModel object.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.loglikelihood-Tuple{HePPCATModel, Any}","page":"Docstrings","title":"HePPCAT.loglikelihood","text":"loglikelihood(M::HePPCATModel,Y)\n\nLog-likelihood of model M with respect to data Y (dropping constant term).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.polar-Tuple{Any}","page":"Docstrings","title":"HePPCAT.polar","text":"polar(A)\n\nPolar factor of A.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.skew-Tuple{Any}","page":"Docstrings","title":"HePPCAT.skew","text":"skew(A)\n\nSkew-symmetrize A by computing (A-A')/2.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateF!","page":"Docstrings","title":"HePPCAT.updateF!","text":"updateF!(M::HePPCATModel,Y,method)\n\nUpdate the factor matrix in M with respect to data Y using method.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HePPCAT.updateF!-Tuple{HePPCATModel, Any, HePPCAT.ExpectationMaximization}","page":"Docstrings","title":"HePPCAT.updateF!","text":"updateF!(M::HePPCATModel,Y,::ExpectationMaximization)\n\nExpectation maximization update of F.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateU!","page":"Docstrings","title":"HePPCAT.updateU!","text":"updateU!(M::HePPCATModel,Y,method)\n\nUpdate the factor eigenvectors M.U with respect to data Y using method.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HePPCAT.updateU!-Tuple{HePPCATModel, Any, HePPCAT.MinorizeMaximize}","page":"Docstrings","title":"HePPCAT.updateU!","text":"updateU!(M::HePPCATModel,Y,::MinorizeMaximize)\n\nMinorize maximize update of M.U using a linear minorizer.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateU!-Tuple{HePPCATModel, Any, HePPCAT.ProjectedGradientAscent{var\"#s19\"} where var\"#s19\"<:Number}","page":"Docstrings","title":"HePPCAT.updateU!","text":"updateU!(M::HePPCATModel,Y,pga::ProjectedGradientAscent)\n\nProjected gradient ascent update of M.U. Supported step size types: Number (i.e., constant step size), InverseLipschitz, and ArmijoSearch (experimental).\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateU!-Tuple{HePPCATModel, Any, HePPCAT.StiefelGradientAscent{var\"#s19\"} where var\"#s19\"<:HePPCAT.ArmijoSearch}","page":"Docstrings","title":"HePPCAT.updateU!","text":"updateU!(M::HePPCATModel,Y,sga::StiefelGradientAscent)\n\nStiefel gradient ascent update of M.U. Supported step size types: ArmijoSearch.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updatev!-Tuple{HePPCATModel, Any, Any}","page":"Docstrings","title":"HePPCAT.updatev!","text":"updatev!(M::HePPCATModel,Y,method)\n\nUpdate the noise variances M.v with respect to data Y using method. Internally calls updatevl(_) to update each entry.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updatevl","page":"Docstrings","title":"HePPCAT.updatevl","text":"updatevl(vl,U,Î»,Yl,method)\n\nCompute update for lth noise variance vl with respect to data Yl using method.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HePPCAT.updatevl-Tuple{Any, Any, Any, Any, HePPCAT.CubicSolvableMinorizer}","page":"Docstrings","title":"HePPCAT.updatevl","text":"updatevl(vl,U,Î»,Yl,::CubicSolvableMinorizer)\n\nMinorize maximize update of vl with cubic solvable minorizer.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updatevl-Tuple{Any, Any, Any, Any, HePPCAT.DifferenceOfConcave}","page":"Docstrings","title":"HePPCAT.updatevl","text":"updatevl(vl,U,Î»,Yl,::DifferenceOfConcave)\n\nDifference of concave update of vl.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updatevl-Tuple{Any, Any, Any, Any, HePPCAT.ExpectationMaximization}","page":"Docstrings","title":"HePPCAT.updatevl","text":"updatevl(vl,U,Î»,Yl,::ExpectationMaximization)\n\nExpectation maximization update of vl.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updatevl-Tuple{Any, Any, Any, Any, HePPCAT.ProjectedVariance}","page":"Docstrings","title":"HePPCAT.updatevl","text":"updatevl(vl,U,Î»,Yl,method::ProjectedVariance)\n\nUpdate variance using method.method then project the variance so that the variance iterate does not go below method.varfloor.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updatevl-Tuple{Any, Any, Any, Any, HePPCAT.QuadraticSolvableMinorizer}","page":"Docstrings","title":"HePPCAT.updatevl","text":"updatevl(vl,U,Î»,Yl,::QuadraticSolvableMinorizer)\n\nMinorize maximize update of vl with quadratic solvable minorizer.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updatevl-Tuple{Any, Any, Any, Any, HePPCAT.RootFinding}","page":"Docstrings","title":"HePPCAT.updatevl","text":"updatevl(vl,U,Î»,Yl,::RootFinding)\n\nRoot-finding (global maximization) update of vl.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateÎ»!-Tuple{HePPCATModel, Any, Any}","page":"Docstrings","title":"HePPCAT.updateÎ»!","text":"updateÎ»!(M::HePPCATModel,Y,method)\n\nUpdate the factor eigenvalues M.Î» with respect to data Y using method. Internally calls updateÎ»j(_) to update each entry.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateÎ»j","page":"Docstrings","title":"HePPCAT.updateÎ»j","text":"updateÎ»j(Î»j,uj,v,Y,method)\n\nCompute update for jth factor eigenvalue Î»j with respect to data Y using method.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#HePPCAT.updateÎ»j-Tuple{Any, Any, Any, Any, HePPCAT.DifferenceOfConcave}","page":"Docstrings","title":"HePPCAT.updateÎ»j","text":"updateÎ»j(Î»j,uj,v,Y,::DifferenceOfConcave)\n\nDifference of concave update of Î»j.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateÎ»j-Tuple{Any, Any, Any, Any, HePPCAT.ExpectationMaximization}","page":"Docstrings","title":"HePPCAT.updateÎ»j","text":"updateÎ»j(Î»j,uj,v,Y,::ExpectationMaximization)\n\nExpectation maximization update of Î»j.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateÎ»j-Tuple{Any, Any, Any, Any, HePPCAT.MinorizeMaximize}","page":"Docstrings","title":"HePPCAT.updateÎ»j","text":"updateÎ»j(Î»j,uj,v,Y,::MinorizeMaximize)\n\nMinorize maximize update of Î»j using the minorizer from\n\nY. Sun, A. Breloy, P. Babu, D. P. Palomar, F. Pascal, and G. Ginolhac, \"Low-complexity algorithms for low rank clutter parameters estimation in radar systems,\" IEEE Transactions on Signal Processing, vol. 64, no. 8, pp. 1986â€“1998, Apr. 2016.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateÎ»j-Tuple{Any, Any, Any, Any, HePPCAT.OptimalQuadraticMinorizer}","page":"Docstrings","title":"HePPCAT.updateÎ»j","text":"updateÎ»j(Î»j,uj,v,Y,::OptimalQuadraticMinorizer)\n\nMinorize maximize update of Î»j using quadratic minorizer with optimized curvature.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateÎ»j-Tuple{Any, Any, Any, Any, HePPCAT.QuadraticMinorizer}","page":"Docstrings","title":"HePPCAT.updateÎ»j","text":"updateÎ»j(Î»j,uj,v,Y,::QuadraticMinorizer)\n\nMinorize maximize update of Î»j using quadratic minorizer.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#HePPCAT.updateÎ»j-Tuple{Any, Any, Any, Any, HePPCAT.RootFinding}","page":"Docstrings","title":"HePPCAT.updateÎ»j","text":"updateÎ»j(Î»j,uj,v,Y,::RootFinding)\n\nRoot-finding (global maximization) update of Î»j.\n\n\n\n\n\n","category":"method"}]
}
